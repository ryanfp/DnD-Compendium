/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => lineArrange
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var lineArrange = class extends import_obsidian.Plugin {
  // Method called when the plugin is loaded 
  async onload() {
    this.addCommand({
      id: "lexisort-lines",
      name: "Lexisort lines",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        editor.replaceSelection(lexiSortLines(selection));
      }
    });
    this.addCommand({
      id: "reverse-lines",
      name: "Reverse lines",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        editor.replaceSelection(reverseLines(selection));
      }
    });
    this.addCommand({
      id: "sort-lines",
      name: "Sort lines",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        editor.replaceSelection(sortLines(selection));
      }
    });
    this.addCommand({
      id: "shuffle-lines",
      name: "Shuffle lines",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        editor.replaceSelection(shuffleLines(selection));
      }
    });
    this.addCommand({
      id: "lexisort-blocks",
      name: "Lexisort blocks",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        editor.replaceSelection(lexiSortBlocks(selection));
      }
    });
    this.addCommand({
      id: "reverse-blocks",
      name: "Reverse blocks",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        editor.replaceSelection(reverseBlocks(selection));
      }
    });
    this.addCommand({
      id: "sort-blocks",
      name: "Sort blocks",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        editor.replaceSelection(sortBlocks(selection));
      }
    });
    this.addCommand({
      id: "shuffle-blocks",
      name: "Shuffle blocks",
      editorCallback: (editor) => {
        const selection = editor.getSelection();
        editor.replaceSelection(shuffleBlocks(selection));
      }
    });
  }
};
var textSize = getComputedStyle(document.body).getPropertyValue("--font-text-size");
var textFont = getComputedStyle(document.body).getPropertyValue("--font-text");
function lexiSortLines(orgText) {
  const lines = orgText.split("\n");
  lines.sort();
  let srtLines = "";
  lines.forEach((line) => {
    if (line.length > 0) {
      srtLines += line + "\n";
    } else {
      srtLines = "\n" + srtLines;
    }
  });
  return srtLines.trimEnd();
}
function reverseLines(orgText) {
  const lines = orgText.split("\n");
  lines.reverse();
  let revLines = "";
  lines.forEach((line) => {
    if (line.length > 0) {
      revLines += line + "\n";
    } else {
      revLines = "\n" + revLines;
    }
  });
  return revLines.trimEnd();
}
function sortLines(orgText) {
  const lines = orgText.split("\n");
  const arr1 = new Arrangement(lines, realLineWidth);
  return orderedText(arr1);
}
function realLineWidth(line) {
  const canvas = document.createElement("canvas");
  const context = canvas.getContext("2d");
  if (!context) {
    throw new Error("Failed to get 2D context");
  }
  context.font = textSize + " " + textFont;
  return Math.round(1e4 * context.measureText(line).width);
}
function shuffleLines(orgText) {
  const lines = orgText.split("\n");
  const arr2 = new Arrangement(lines, randomLineWidth);
  return orderedText(arr2);
}
function randomLineWidth(line) {
  if (line.length > 0)
    return Math.round(1e4 * (Math.random() + 1));
  else
    return 0;
}
var Arrangement = class {
  // Creates a key for each unique line-width and associates line to respective slot
  constructor(linesList, lineFunction) {
    linesList.forEach((line) => {
      const width = lineFunction(line);
      if (!(width in this)) {
        this[width] = line;
      } else {
        this[width] = this[width].concat("\n" + line);
      }
    });
  }
};
function orderedText(orderedLines) {
  let finalText = "";
  for (const lineKey in orderedLines) {
    finalText += orderedLines[lineKey] + "\n";
  }
  return finalText.trimEnd();
}
function sortBlocks(orgText) {
  const lines = orgText.split("\n");
  const tree = buildTree(lines);
  sortTree(tree);
  const sortedLines = flattenTree(tree);
  return sortedLines.join("\n");
  function sortTree(node) {
    node.children.sort((a, b) => realLineWidth(a.line || "") - realLineWidth(b.line || ""));
    node.children.forEach((child) => sortTree(child));
  }
}
function shuffleBlocks(orgText) {
  const lines = orgText.split("\n");
  const tree = buildTree(lines);
  sortTree(tree);
  const sortedLines = flattenTree(tree);
  return sortedLines.join("\n");
  function sortTree(node) {
    node.children.sort((a, b) => randomLineWidth(a.line || "") - randomLineWidth(b.line || ""));
    node.children.forEach((child) => sortTree(child));
  }
}
function lexiSortBlocks(orgText) {
  const lines = orgText.split("\n");
  const tree = buildTree(lines);
  sortTree(tree);
  const sortedLines = flattenTree(tree);
  return sortedLines.join("\n");
  function sortTree(node) {
    node.children.sort((a, b) => (a.line || "").localeCompare(b.line || ""));
    node.children.forEach((child) => sortTree(child));
  }
}
function reverseBlocks(orgText) {
  const lines = orgText.split("\n");
  const tree = buildTree(lines);
  sortTree(tree);
  const sortedLines = flattenTree(tree);
  return sortedLines.join("\n");
  function sortTree(node) {
    node.children.reverse();
    node.children.forEach((child) => sortTree(child));
  }
}
var TreeNode = class {
  // Children nodes
  constructor(line, level) {
    this.line = line;
    this.level = level;
    this.children = [];
  }
};
function getLevel(line) {
  var _a, _b;
  let level = 0;
  const indentation = getIndentation(line);
  if (/^\s*#\s*/.test(line)) {
    const headingLevel = (_b = (_a = line.match(/^#+/)) == null ? void 0 : _a[0].length) != null ? _b : 0;
    level = headingLevel;
    return level;
  } else {
    level = 10 + indentation;
    return level;
  }
}
function getIndentation(line) {
  var _a, _b;
  return (_b = (_a = line.match(/^\s*/)) == null ? void 0 : _a[0].length) != null ? _b : 0;
}
function buildTree(lines) {
  const root = new TreeNode(null, -1);
  const stack = [root];
  lines.forEach((line) => {
    const level = getLevel(line);
    const node = new TreeNode(line, level);
    while (stack[stack.length - 1].level >= level) {
      stack.pop();
    }
    stack[stack.length - 1].children.push(node);
    stack.push(node);
  });
  return root;
}
function flattenTree(node) {
  let lines = [];
  if (node.line !== null) {
    lines.push(node.line);
  }
  node.children.forEach((child) => {
    lines = lines.concat(flattenTree(child));
  });
  return lines;
}


/* nosourcemap */